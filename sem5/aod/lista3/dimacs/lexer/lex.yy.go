//line lexer.l:2

package lexer

import (
    "io"
    "os"
    "log"
    "dijkstra/dimacs/token"
)


// return type of yy.Lex()
type YYtype = token.Token


// type of Scanner.Context
type YYcontext interface{}


var yytext string




//line lex.yy.go:27

// START OF SKELL ------------------------------------------------------
// A lexical scanner generated by flexgo

type Scanner struct {
	In   io.Reader
	Out  io.Writer
	
	Filename      string
	Wrap          func(*Scanner) bool
	IsInteractive func(io.Reader) bool
	Context       YYcontext

	lastAcceptingState   int
	lastAcceptingCpos    int
	debug                bool
	start                int
	stateBuf             []int
	statePtr             int
	fullState            int
	fullMatch            int
	fullLp               int
	lp                   int
	lookingForTrailBegin int
	holdChar             byte
	cBufP                int
	didBufferSwitchOnEof bool
	textPtr              int
	nChars               int
	init                 bool
	moreFlag             bool
    moreLen              int

	// buffer
	inputFile    io.Reader
	chBuf        []byte // input buffer
	bufPos       int    // current position in input buffer
	bufSize      int
	bufNChars    int
	Interactive  bool
	atBol        int // 0 (false) or 1 (true)
	fillBuffer   bool
	bufferStatus int
}

func NewScanner() *Scanner {
	yy := Scanner{
		
		In:            os.Stdin,
		Out:           os.Stdout,
		Wrap:          func(yyy *Scanner) bool { return true },
		IsInteractive: func(file io.Reader) bool { return yyInteractiveDefault },
		bufSize:       yyBufSize,
		chBuf:         make([]byte, yyBufSize+2),
		start:         1,
		stateBuf:      make([]int, yyBufSize+2),
		atBol:         1,
		debug:         yyFlexDebug,
		fillBuffer:    true,
	}
	return &yy
}

func (yy *Scanner) NewFile() {
	yy.Restart(yy.In)
}

const yyEndOfBufferChar = 0

const yyBufSize = 32768

const (
	eobActEndOfFile    = 0
	eobActContinueScan = 1
	eobActLastMatch    = 2
)

const (
	yyBufferNew        = 0
	yyBufferNormal     = 1
	yyBufferEofPending = 2
)

// [1.0] the user's section 1 definitions and yytext/yyin/yyout/yy_state_type/yylineno etc. def's & init go here
/* Begin user sect3 */
const yyFlexDebug = false

const yyInteractiveDefault = true
// SKEL ----------------------------------------------------------------

// [1.5] DFA------------------------------------------------------------
// SKEL ----------------------------------------------------------------

// [4.0] data tables for the DFA go here -------------------------------
const yyNumRules = 9
const yyEndOfBuffer = 10
var yyAccept = [17]int16{   0,
        0,    0,   10,    8,    1,    2,    7,    5,    3,    4,
        8,    1,    7,    3,    6,    0,
    }

var yyEc = [256]byte{    0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    2,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    4,    4,    4,
        4,    4,    4,    4,    4,    4,    4,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    5,    1,    6,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    7,    1,    1,    8,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,
    }

var yyMeta = [9]byte{    0,
        1,    1,    2,    1,    1,    1,    1,    1,
    }

var yyBase = [18]uint16{   0,
        0,    0,   15,   16,   12,   16,    9,   16,    0,   16,
        5,    9,    6,    0,   16,   16,    8,
    }

var yyDef = [18]int16{   0,
       16,    1,   16,   16,   16,   16,   16,   16,   17,   16,
       16,   16,   16,   17,   16,    0,   16,
    }

var yyNxt = [25]uint16{   0,
        4,    5,    6,    7,    8,    9,   10,   11,   14,   13,
       12,   15,   13,   12,   16,    3,   16,   16,   16,   16,
       16,   16,   16,   16,
    }

var yyChk = [25]int16{   0,
        1,    1,    1,    1,    1,    1,    1,    1,   17,   13,
       12,   11,    7,    5,    3,   16,   16,   16,   16,   16,
       16,   16,   16,   16,
    }

//line lexer.l:1

//line lex.yy.go:188
// SKEL ----------------------------------------------------------------

const yyInitial  = 0

const yyReadBufSize = 16384

func (yy *Scanner) input(offset, maxRead int) int {

// [5.0] fread()/read() definition of yy_INPUT goes here ---------------
// nothing here, all moved to skeleton
// SKEL ----------------------------------------------------------------

	if yy.Interactive {
		b := make([]byte, 1)
		var n int
		for n = 0; n < maxRead; n++ {
			nn, err := yy.inputFile.Read(b)
			if err != nil && err != io.EOF {
				log.Panicln("Reading 1 byte:", err)
			}
			if nn < 1 {
				break
			}
			yy.chBuf[offset+n] = b[0]
			if b[0] == '\n' {
				n++
				break
			}
		}
		return n
	}

	n, err := yy.inputFile.Read(yy.chBuf[offset:offset+maxRead])
	if err != nil  && err != io.EOF {
		log.Panicf("Reading %d bytes: %v\n", maxRead, err)
	}
	return n
}

/* [6.0] YY_RULE_SETUP definition goes here --------------------------*/

// SKEL ----------------------------------------------------------------

// The main scanner function which does all the work.
func (yy *Scanner) Lex() YYtype {
	var yyCurrentState int
	var yyBp, yyCp int
	var yyAct int
	var yytext []byte
	var yyleng int
	
	_ = yytext
	_ = yyleng
	
	if !yy.init {
		yy.init = true
		
		if yy.In == nil {
			yy.In = os.Stdin
		}
		if yy.Out == nil {
			yy.Out = os.Stdout
		}
		yy.initBuffer(yy.In)
		yy.loadBufferState()
	}

	yyout := yy.Out
	_ = yyout

// [7.0] user's declarations go here -----------------------------------
//line lexer.l:25


//line lex.yy.go:263
// SKEL ----------------------------------------------------------------

	for { // loops until end-of-file is reached

// [8.0] yy''more-related code goes here -------------------------------
// SKEL ----------------------------------------------------------------

		yyCp = yy.cBufP

		/* Support of yytext. */
		yy.chBuf[yyCp] = yy.holdChar

		// yyBp points to the position in yy_ch_buf of the start of
		// the current run.
		yyBp = yyCp

// [9.0] code to set up and find next match goes here ------------------
		yyCurrentState = yy.start
yyMatch:
		for {
			yyC := int(yyEc[yy.chBuf[yyCp]])
						if yyAccept[yyCurrentState] != 0 {
				yy.lastAcceptingState = yyCurrentState
				yy.lastAcceptingCpos = yyCp
			}
			for int(yyChk[int(yyBase[yyCurrentState])+yyC]) != yyCurrentState {
				yyCurrentState = int(yyDef[yyCurrentState])
				if yyCurrentState >= 17 {
					yyC = int(yyMeta[yyC])
				}
			}
			yyCurrentState = int(yyNxt[int(yyBase[yyCurrentState])+yyC])
			yyCp++
			if yyBase[yyCurrentState] == 16 {
				break
			}
		}
// SKEL ----------------------------------------------------------------

	yyFindAction:

// [10.0] code to find the action number goes here ---------------------
		yyAct = int(yyAccept[yyCurrentState])
		if yyAct == 0 {
			// have to back up
			yyCp = yy.lastAcceptingCpos
			yyCurrentState = yy.lastAcceptingState
			yyAct = int(yyAccept[yyCurrentState])
		}
// SKEL ----------------------------------------------------------------

		yy.textPtr = yyBp

// [2.0] code to fiddle yytext and yyleng for yy''more() goes here -------
	yyleng = yyCp - yyBp
// SKEL ----------------------------------------------------------------

		yy.holdChar = yy.chBuf[yyCp]
		yy.chBuf[yyCp] = 0

// [3.0] code to copy yytext_ptr to yytext[] goes here, if %array ------
// SKEL ----------------------------------------------------------------

		yy.cBufP = yyCp
		yytext = yy.chBuf[yy.textPtr:yyCp]
 
// [11.0] code for yylineno update goes here ---------------------------

// SKEL ----------------------------------------------------------------

	doAction: // This label is used only to access EOF actions.

// [12.0] debug code goes here -----------------------------------------
// SKEL ----------------------------------------------------------------

		switch yyAct { // beginning of action switch

// [13.0] actions go here ----------------------------------------------
			case 0: // must back up
			// undo the effects of yy_DO_BEFORE_ACTION
			yy.chBuf[yyCp] = yy.holdChar
			yyCp = yy.lastAcceptingCpos
			yyCurrentState = yy.lastAcceptingState
			goto yyFindAction

case 1:

//line lexer.l:27
;   // Ignore whitespace
case 2:
/* rule 2 can match eol */

	

//line lexer.l:29
;
case 3:

	

//line lexer.l:31
; // Ignore comments
case 4:

	

//line lexer.l:34
{
                    return token.NewToken(token.PROBLEM, "p")
                }
case 5:

	

//line lexer.l:38
{
                    return token.NewToken(token.ARC, "a")
                }
case 6:

	

//line lexer.l:42
{
                    return token.NewToken(token.PROBLEM_TYPE, "sp")
                }
case 7:

	

//line lexer.l:46
{
                    return token.NewToken(token.NUMBER, string(yytext))
                }
case 8:
/* rule 8 can match eol */

	

//line lexer.l:50
;   // Ignore unrecognized characters
case 9:

	

//line lexer.l:52
yyout.Write(yytext) 
//line lex.yy.go:411
case (yyEndOfBuffer + yyInitial  + 1) :
	
var __ YYtype
return __
 
// SKEL ----------------------------------------------------------------

		case yyEndOfBuffer:
			/* Amount of text matched not including the EOB char. */
			yyAmountOfMatchedText := yyCp - yy.textPtr - 1

			/* Undo the effects of yy_DO_BEFORE_ACTION. */
			yy.chBuf[yyCp] = yy.holdChar
			 
			if yy.bufferStatus == yyBufferNew {
				/* We're scanning a new file or input source.  It's
				 * possible that this happened because the user
				 * just pointed yyin at a new source and called
				 * yylex().  If so, then we have to assure
				 * consistency between yy_CURRENT_BUFFER and our
				 * globals.  Here is the right place to do so, because
				 * this is the first action (other than possibly a
				 * back-up) that will match for the new input source.
				 */
				yy.nChars = yy.bufNChars
				yy.inputFile = yy.In
				yy.bufferStatus = yyBufferNormal
			}

			/* Note that here we test for yy_c_buf_p "<=" to the position
			 * of the first EOB in the buffer, since yy_c_buf_p will
			 * already have been incremented past the NUL character
			 * (since all states make transitions on EOB to the
			 * end-of-buffer state).  Contrast this with the test
			 * in input().
			 */
			if yy.cBufP <= yy.nChars {
				/* This was really a NUL. */
				var yyNextState int

				yy.cBufP = yy.textPtr + yyAmountOfMatchedText

				yyCurrentState = yy.getPreviousState()

				/* Okay, we're now positioned to make the NUL
				 * transition.  We couldn't have
				 * yy_get_previous_state() go ahead and do it
				 * for us because it doesn't know how to deal
				 * with the possibility of jamming (and we don't
				 * want to build jamming into it because then it
				 * will run more slowly).
				 */

				yyNextState = yy.tryNulTrans(yyCurrentState)

				yyBp = yy.textPtr + 0 

				if yyNextState != 0 {
					/* Consume the NUL. */
					yy.cBufP++
					yyCp = yy.cBufP
					yyCurrentState = yyNextState
					goto yyMatch
				} else {

// [14.0] code to do back-up for compressed tables and set up yy_cp goes here
				yyCp = yy.cBufP
// SKEL ----------------------------------------------------------------

					goto yyFindAction
				}

			} else {

				switch yy.getNextBuffer() {
				case eobActEndOfFile:
					yy.didBufferSwitchOnEof = false

					if yy.Wrap(yy) {
						// Note: because we've taken care in
						// yy_get_next_buffer() to have set up
						// yytext, we can now set up
						// yy.cBufP so that if some total
						// hoser (like flex itself) wants to
						// call the scanner after we return the
						// yy_NULL, it'll still work - another
						// yy_NULL will get returned.
						yy.cBufP = yy.textPtr + 0 

						yyAct = (yyEndOfBuffer + ((yy.start - 1) / 2)  + 1) 
						goto doAction
					} else {
						if !yy.didBufferSwitchOnEof {
							yy.NewFile()
						}
					}
				case eobActContinueScan:
					yy.cBufP = yy.textPtr + yyAmountOfMatchedText

					yyCurrentState = yy.getPreviousState()

					yyCp = yy.cBufP
					yyBp = yy.textPtr + 0 
					goto yyMatch
				case eobActLastMatch:
					yy.cBufP = yy.nChars

					yyCurrentState = yy.getPreviousState()

					yyCp = yy.cBufP
					yyBp = yy.textPtr + 0 
					goto yyFindAction
				}
			}

		default:
			log.Panicln("fatal flex scanner internal error--no action found:", yyAct)
		} // end of action switch
	} // end of scanning one token
	var yyvalue YYtype
	return yyvalue
} // end of yylex

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *	EOB_ACT_LAST_MATCH -
 *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *	EOB_ACT_END_OF_FILE - end of file
 */
func (yy *Scanner) getNextBuffer() int {

	var numberToMove int
	var retval int

	if yy.cBufP > yy.nChars+1 {
		log.Panic("fatal flex scanner internal error--end of buffer missed")
	}

	if !yy.fillBuffer {
		// Don't try to fill the buffer, so this is an EOF.
		if yy.cBufP-yy.textPtr-0  == 1 {
			// We matched a single character, the EOB, so
			// treat this as a final EOF.
			return eobActEndOfFile
		} else {
			// We matched some text prior to the EOB, first
			// process it.
			return eobActLastMatch
		}
	}

	// Try to read more data.

	// First move last chars to start of buffer.
	numberToMove = yy.cBufP - yy.textPtr - 1

	copy(yy.chBuf, yy.chBuf[yy.textPtr:yy.textPtr+numberToMove])

	if yy.bufferStatus == yyBufferEofPending {
		// don't do the read, it's not guaranteed to return an EOF,
		// just force an EOF
		yy.nChars = 0
		yy.bufNChars = 0
	} else {
		numToRead := yy.bufSize - numberToMove - 1

		for numToRead <= 0 {
			// Not enough room in the buffer - grow it.

			yyCBufPOffset := yy.cBufP

			new_size := yy.bufSize * 2

			if new_size <= 0 {
				yy.bufSize += yy.bufSize / 8
			} else {
				yy.bufSize *= 2
			}

			// Include room in for 2 EOB chars.
			bb := make([]byte, yy.bufSize+2-len(yy.chBuf))
			yy.chBuf = append(yy.chBuf, bb...)

			yy.cBufP = yyCBufPOffset

			numToRead = yy.bufSize - numberToMove - 1

		}

		if numToRead > yyReadBufSize {
			numToRead = yyReadBufSize
		}

		// Read in more data.
		yy.nChars = yy.input(numberToMove, numToRead)
		yy.bufNChars = yy.nChars
	}

	if yy.nChars == 0 {
		if numberToMove == 0  {
			retval = eobActEndOfFile
			yy.Restart(yy.In)
		} else {
			retval = eobActLastMatch
			yy.bufferStatus = yyBufferEofPending
		}
	} else {
		retval = eobActContinueScan
	}

	if yy.nChars+numberToMove > yy.bufSize {
		// Extend the array by 50%, plus the number we really need. *
		newSize := yy.nChars + numberToMove + (yy.nChars >> 1)
		if leng := len(yy.chBuf); leng < newSize {
			chBuf := make([]byte, newSize-leng)
			yy.chBuf = append(yy.chBuf, chBuf...)
		}
	}

	yy.nChars += numberToMove
	//yy.bufNChars += numberToMove // TODO: missing in C skel, bug?
	yy.chBuf[yy.nChars] = yyEndOfBufferChar
	yy.chBuf[yy.nChars+1] = yyEndOfBufferChar

	yy.textPtr = 0

	return retval
}

/* yy_get_previous_state - get the state just before the EOB char was reached */
func (yy *Scanner) getPreviousState() int {

	var yyCurrentState int
	var yyCp int

// [15.0] code to get the start state into yy_current_state goes here --
	yyCurrentState = yy.start
// SKEL ----------------------------------------------------------------

	for yyCp = yy.textPtr + 0 ; yyCp < yy.cBufP; yyCp++ {

// [16.0] code to find the next state goes here ------------------------
		yyC := yyIfElse(yy.chBuf[yyCp] != 0, int(yyEc[yy.chBuf[yyCp]]), 1)
				if yyAccept[yyCurrentState] != 0 {
			yy.lastAcceptingState = yyCurrentState
			yy.lastAcceptingCpos = yyCp
		}
		for int(yyChk[int(yyBase[yyCurrentState])+yyC]) != yyCurrentState {
			yyCurrentState = int(yyDef[yyCurrentState])
			if yyCurrentState >= 17 {
				yyC = int(yyMeta[yyC])
			}
		}
		yyCurrentState = int(yyNxt[int(yyBase[yyCurrentState])+yyC])
// SKEL ----------------------------------------------------------------

	}
	return yyCurrentState
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *      next_state = yy_try_NUL_trans( current_state );
 */
func (yy *Scanner) tryNulTrans(yyCurrentState int) int {

	var yyIsJam bool
	var yyCp int
	_ = yyCp

// [17.0] code to find the next state, and perhaps do backing up, goes here
	yyCp = yy.cBufP

	yyC := 1
		if yyAccept[yyCurrentState] != 0 {
		yy.lastAcceptingState = yyCurrentState
		yy.lastAcceptingCpos = yyCp
	}
	for int(yyChk[int(yyBase[yyCurrentState])+yyC]) != yyCurrentState {
		yyCurrentState = int(yyDef[yyCurrentState])
		if yyCurrentState >= 17 {
			yyC = int(yyMeta[yyC])
		}
	}
	yyCurrentState = int(yyNxt[int(yyBase[yyCurrentState])+yyC])
	if yyCurrentState == 16 {
		yyIsJam = true
	}
// SKEL ----------------------------------------------------------------

	if yyIsJam {
		return 0
	}
	return yyCurrentState
}

func (yy *Scanner) Unput(c byte) {

	yy_bp := yy.textPtr
    yy_cp := yy.cBufP

	// undo effects of setting up yytext
	yy.chBuf[yy_cp] = yy.holdChar

	if yy_cp < 2 {
		// need to shift things up to make room
		// +2 for EOB chars.

		numberToMove := yy.nChars + 2
		moveTo := yy.bufSize - yy.nChars

		copy(yy.chBuf[moveTo:], yy.chBuf[:numberToMove])

		yy_cp += moveTo
		yy_bp += moveTo

		yy.nChars = yy.bufSize
		yy.bufNChars = yy.bufSize

		if yy_cp < 2 {
			log.Fatalln("flex scanner push-back overflow")
		}
	}

	yy_cp--
	yy.chBuf[yy_cp] = c

// [18.0] update yylineno here -----------------------------------------
// SKEL ----------------------------------------------------------------

	yy.textPtr = yy_bp
	yy.holdChar = yy.chBuf[yy_cp]
	yy.cBufP = yy_cp
}

func (yy *Scanner) Input() (byte, error) {

	yy.chBuf[yy.cBufP] = yy.holdChar

	if yy.chBuf[yy.cBufP] == yyEndOfBufferChar {
		// yy_c_buf_p now points to the character we want to return.
		// If this occurs *before* the EOB characters, then it's a
		// valid NUL; if not, then we've hit the end of the buffer.
		if yy.cBufP < yy.nChars {
			// This was really a NUL.
			yy.chBuf[yy.cBufP] = 0
		} else {
			// need more input
			offset := yy.cBufP - yy.textPtr
			yy.cBufP++

			switch yy.getNextBuffer() {
			case eobActLastMatch:
					/* This happens because yy_g_n_b()
					 * sees that we've accumulated a
					 * token and flags that we need to
					 * try matching the token before
					 * proceeding.  But for input(),
					 * there's no matching to consider.
					 * So convert the EOB_ACT_LAST_MATCH
					 * to EOB_ACT_END_OF_FILE.
					 */

					/* Reset buffer status. */
				yy.Restart(yy.In)

				fallthrough

			case eobActEndOfFile:
				if yy.Wrap(yy) {
					return 0, io.EOF
				}

				if !yy.didBufferSwitchOnEof {
					yy.Restart(yy.In)
				}

				return yy.Input()

			case eobActContinueScan:
				yy.cBufP = yy.textPtr + offset
			}
		}
	}

	c := yy.chBuf[yy.cBufP]
	yy.chBuf[yy.cBufP] = 0	// preserve yytext
	yy.cBufP++
	yy.holdChar = yy.chBuf[yy.cBufP]

// [19.0] update BOL and yylineno --------------------------------------
// SKEL ----------------------------------------------------------------

return c, nil
}

/** Immediately switch to a different input stream.
 * @param input_file A readable stream.
 *
 * @note This function does not reset the start condition to @c yyInitial  .
 */
func (yy *Scanner) Restart(input_file io.Reader) {
	yy.initBuffer(input_file)
	yy.loadBufferState()
}

func (yy *Scanner) loadBufferState() {
	yy.nChars = yy.bufNChars
	yy.cBufP = yy.bufPos
	yy.textPtr = yy.cBufP
	yy.In = yy.inputFile
	yy.holdChar = yy.chBuf[yy.cBufP]
}

/* Initializes or reinitializes a buffer.
 * This function is sometimes called more than once on the same buffer,
 * such as during a yyrestart() or at EOF.
 */
func (yy *Scanner) initBuffer(file io.Reader) {

	yy.flushBuffer()

	yy.inputFile = file

	yy.fillBuffer = true

	yy.Interactive = yy.IsInteractive(file)

}

/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
 * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
 *
 */
func (yy *Scanner) flushBuffer() {

	yy.bufNChars = 0

	/* We always need two end-of-buffer characters.  The first causes
	 * a transition to the end-of-buffer state.  The second causes
	 * a jam in that state.
	 */
	yy.chBuf[0] = yyEndOfBufferChar
	yy.chBuf[1] = yyEndOfBufferChar

	yy.bufPos = 0

	yy.atBol = 1
	yy.bufferStatus = yyBufferNew

	yy.loadBufferState()
}

func yyIfElse(b bool, i1, i2 int) int {
	if b {
		return i1
	}
	return i2
}

func YYmain(filenames ...string) (interface{}, error) {

	var errval error

	yy := NewScanner()

	yy.Filename = "<stdin>"

	if len(filenames) > 0 {
		yy.Filename = filenames[0]
		yy.In, errval = os.Open(yy.Filename)
		if errval != nil {
			return nil, errval
		}
		yy.Wrap = func(yyy *Scanner) bool {
			if len(filenames) == 0 {
				// should not happen
				return true
			}
			yyy.In.(*os.File).Close()
			filenames = filenames[1:]
			if len(filenames) == 0 {
				return true
			}
			yyy.Filename = filenames[0]
			yyy.In, errval = os.Open(yyy.Filename)
			if errval != nil {
				return true
			}
			return false
		}
	}

	return yy.Lex(), errval

}

// END OF SKELL --------------------------------------------------------
//line lexer.l:52



func yywrap() int {
    return 1
}

func (s *Scanner) Error(error string)  {
    return
}
